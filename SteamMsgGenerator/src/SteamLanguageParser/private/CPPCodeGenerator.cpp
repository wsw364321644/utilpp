#include "CPPCodeGenerator.h"
#include <stack>
const char CPP_CODE_GEN_NAME[] = "CPPCodeGenerator";
volatile static TNamedClassAutoRegister_t<FCPPCodeGenerator> NamedClassAutoRegister(CPP_CODE_GEN_NAME);

class FCPPHandle :public ICommonHandle {
public:
    FCPPHandle(std::ostream* _pstream) :pstream(_pstream) {}
    bool IsValid() const override {
        return pstream != nullptr;
    }
    std::ostream* pstream;
};
class FNamespaceHandle :public FCPPHandle {
public:
    FNamespaceHandle(std::ostream* _pstream) :FCPPHandle(_pstream) {}
    ~FNamespaceHandle() {
        auto& stream = *pstream;
        stream << "}" << std::endl;
    }
};

void FCPPCodeGenerator::EmitSourceFile(std::ostream* stream, std::vector<std::string>& IncludeHeaders, NamespaceNode_t& NamespaceNode)
{
    auto& outStream = *stream;
    outStream << "// Generated by SteamLanguageParser" << std::endl;
    outStream << "#pragma once" << std::endl;
    outStream << std::endl;

    for (const auto& header : IncludeHeaders) {
        outStream << "#include \"" << header << "\"" << std::endl;
    }
    outStream << "#include <" << "stdint.h" << ">" << std::endl;
    outStream << std::endl;

    auto ItrNSNodeFunc = [&](this auto&& self, NamespaceNode_t& NamespaceNode)->void {
        FCommonHandlePtr NSHandle;
        if (!NamespaceNode.Name.empty()) {
            NSHandle = BeginNamespace(&outStream, NamespaceNode.Name);
        }
        for (auto& type : NamespaceNode.Types) {
                EmitType(&outStream, type.get());
        }
        for (auto& [ns, pNamespaceNode] : NamespaceNode.SubNamespaces) {
            self(*pNamespaceNode);
        }
        };
    ItrNSNodeFunc(NamespaceNode);

}

FCommonHandlePtr FCPPCodeGenerator::BeginNamespace(std::ostream* pstream, std::string_view spaceName)
{
    auto& stream = *pstream;
    stream << "namespace " << spaceName << " {" <<std::endl;
    return std::make_shared<FNamespaceHandle>(pstream);
}

void FCPPCodeGenerator::EmitType(std::ostream* pstream, FTypeNode* node)
{
    auto& stream = *pstream;
    auto pClassNode = dynamic_cast<FClassNode*>(node);
    auto pEnumNode = dynamic_cast<FEnumNode*>(node);
    if (pClassNode) {
        
    }
    else if (pEnumNode) {
        stream << "enum class " << pEnumNode->Name ;
        auto petype = std::get_if<EBuildInType>(&pEnumNode->Type);
        auto pvtype = std::get_if<std::string_view>(&pEnumNode->Type);
        if (pvtype) {
            stream << ":" << *pvtype;
        }
        else if (*petype!= EBuildInType::BIT_NONE) {
            stream << ":" << GetCPPBuildInTypeView(*petype);
        }
        stream << std::endl;
        stream << "{" << std::endl;

        for (auto& child:pEnumNode->Children) {
            if (!child->bEmit) {
                continue; 
            }
            stream << child->Name;
            if (child->DefaultValue.size() > 0) {
                stream << " = ";
                bool bFirst{true};
                for (auto& val : child->DefaultValue) {
                    if (!bFirst) {
                        stream <<"|";
                    }
                    else {
                        bFirst = false;
                    }
                    stream << val;
                }
            }
            stream << "," << std::endl;
        }

        stream << "};" << std::endl;
    }
}

bool FCPPCodeGenerator::SupportsNamespace()
{
    return true;
}

bool FCPPCodeGenerator::SupportsUnsignedTypes()
{
    return true;
}
